<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const bgMusic = document.getElementById("bgMusic");
  const audioIcon = document.getElementById("audio-icon");
  const audioPath = document.getElementById("audio-icon-path");
  let musicMuted = true;

  document.body.addEventListener("click", () => {
    if (bgMusic.muted) {
      bgMusic.muted = false;
      bgMusic.play();
      musicMuted = false;
    }
  }, { once: true });

  audioIcon.addEventListener("click", (event) => {
    event.stopPropagation();
    if (musicMuted) {
      bgMusic.play();
      audioPath.setAttribute("d", "M3 10v4h4l5 5V5l-5 5H3z");
      musicMuted = false;
    } else {
      bgMusic.pause();
      audioPath.setAttribute("d", "M16.5 12c0-1.77-1.02-3.29-2.5-4.03v8.06c1.48-.74 2.5-2.26 2.5-4.03z M19 12c0 2.21-1.2 4.15-3 5.19v-2.17c.61-.55 1-1.35 1-2.22s-.39-1.67-1-2.22V6.81c1.8 1.04 3 2.98 3 5.19z M3 10v4h4l5 5V5l-5 5H3z");
      musicMuted = true;
    }
  });

  let rotationSpeedX = 0.005;
  let rotationSpeedY = 0.005;
  let focalLength = 3000;
  let targetFocalLength = 300;
  let numPoints = 261;
  let targetPoints = 261;
  let sphereRadius = Math.min(window.innerWidth, window.innerHeight) * 0.4;
  let points = [];

  const isMobile = window.innerWidth <= 768;

  function generateFibonacciSphere(n) {
    let pts = [];
    const phi = Math.PI * (3 - Math.sqrt(5));
    const words = ["ABBY", "WORLD"];
    for (let i = 0; i < n; i++) {
      let y = 1 - (i / (n - 1)) * 2;
      let radius = Math.sqrt(1 - y * y);
      let theta = phi * i;
      let x = Math.cos(theta) * radius;
      let z = Math.sin(theta) * radius;
      let word = words[Math.floor(Math.random() * words.length)];
      pts.push({ x: x * sphereRadius, y: y * sphereRadius, z: z * sphereRadius, word });
    }
    return pts;
  }

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    sphereRadius = Math.min(canvas.width, canvas.height) * 0.4;
    points = generateFibonacciSphere(numPoints);
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();

  function rotateY(point, angle) {
    const cosA = Math.cos(angle), sinA = Math.sin(angle);
    return {
      x: cosA * point.x + sinA * point.z,
      y: point.y,
      z: -sinA * point.x + cosA * point.z,
      word: point.word
    };
  }

  function rotateX(point, angle) {
    const cosA = Math.cos(angle), sinA = Math.sin(angle);
    return {
      x: point.x,
      y: cosA * point.y - sinA * point.z,
      z: sinA * point.y + cosA * point.z,
      word: point.word
    };
  }

  let angleX = 0, angleY = 0;
  let mouseX = 0, mouseY = 0;

  document.addEventListener("mousemove", e => {
    mouseX = e.clientX / window.innerWidth;
    mouseY = e.clientY / window.innerHeight;
  });

  let toggleDirection = true;
  setInterval(() => {
    if (toggleDirection) {
      targetFocalLength = 3000;
      targetPoints = 400;
    } else {
      targetFocalLength = 1200;
      targetPoints = 100;
    }
    toggleDirection = !toggleDirection;
  }, 6000);

  function animateValues() {
    focalLength += (targetFocalLength - focalLength) * 0.02;
    if (Math.abs(targetPoints - numPoints) > 1) {
      numPoints += (targetPoints - numPoints) * 0.05;
      points = generateFibonacciSphere(Math.round(numPoints));
    }
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    animateValues();

    rotationSpeedX = 0.001 + (mouseY - 0.5) * 0.02;
    rotationSpeedY = 0.001 + (mouseX - 0.5) * 0.02;

    let transformedPoints = points.map(p => rotateX(rotateY(p, angleY), angleX));
    transformedPoints.sort((a, b) => b.z - a.z);

    transformedPoints.forEach(p => {
      let scale = focalLength / (focalLength + Math.abs(p.z));
      let x2D = canvas.width / 2 + p.x * scale;
      let y2D = canvas.height / 2 + p.y * scale;

      let depthFactor = (p.z + sphereRadius) / (2 * sphereRadius);
      let brightness = depthFactor * 255;

      ctx.globalAlpha = p.z < 0 ? 0.5 : 1.0;
      let fontScale = isMobile ? 0.8 : 1.0;
      let fontSize = p.z > 0 ? ((8 + 6 * scale) * fontScale) : ((6 + 4 * scale) * fontScale);
      ctx.fillStyle = `rgb(${brightness},${brightness},${brightness})`;
      ctx.font = `${fontSize}px Arial`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(p.word, x2D, y2D);
    });

    ctx.globalAlpha = 1.0;
    angleX += rotationSpeedX;
    angleY += rotationSpeedY;
    requestAnimationFrame(draw);
  }

  draw();
</script>
